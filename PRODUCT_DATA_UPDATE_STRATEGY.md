# ROWELL产品数据更新策略

**文档版本**: 1.0  
**创建日期**: 2025-01-03  
**作者**: 网站建设总工程师  
**目的**: 解决新爬取数据与现有产品库的冲突和重复问题

---

## 执行摘要

ROWELL网站当前拥有**2,623个产品**，分布在**12个品牌**中。当新的爬虫任务返回产品数据时，需要明确的策略来处理数据冲突、重复和更新。本文档提供了完整的数据更新策略和实施方案。

**核心策略**: **智能合并** - 基于productId判断冲突，新数据优先更新，保留现有产品的关联关系（分类、询价记录等）。

---

## 第一部分：现有产品库分析

### 1.1 数据库现状

根据数据库查询结果，现有产品库情况如下：

| 指标 | 数值 | 说明 |
|------|------|------|
| **总产品数** | 2,623 | 所有品牌的产品总数 |
| **品牌数量** | 12 | 包含11个主要品牌 + 1个未知品牌 |
| **唯一零件号** | 2,623 | 每个零件号唯一 |
| **唯一产品ID** | 2,623 | 每个产品ID唯一（格式：PREFIX-partNumber） |

### 1.2 品牌分布

| 品牌 | 前缀 | 产品数量 | 占比 |
|------|------|---------|------|
| Waters | WATS | 1,022 | 39.0% |
| Agilent | AGIL | 571 | 21.8% |
| Thermo Fisher | THER | 397 | 15.1% |
| Phenomenex | PHEN | 258 | 9.8% |
| Restek | REST | 144 | 5.5% |
| Sigma-Aldrich | SIGM | 91 | 3.5% |
| Merck | MERC | 52 | 2.0% |
| Shimadzu | SHIM | 38 | 1.4% |
| PerkinElmer | PERK | 24 | 0.9% |
| Dionex | DION | 15 | 0.6% |
| YMC | YMC | 9 | 0.3% |
| Unknown | UNKN | 2 | 0.1% |

### 1.3 数据唯一性分析

**关键发现**:

1. ✅ **productId唯一性**: 100%唯一（2,623个产品，2,623个唯一ID）
2. ✅ **partNumber唯一性**: 100%唯一（2,623个产品，2,623个唯一零件号）
3. ⚠️ **跨品牌重复**: 存在**10个零件号**在不同品牌中重复

**跨品牌重复示例**:

| 零件号 | 出现次数 | 涉及品牌 | 说明 |
|--------|---------|---------|------|
| 186000273 | 2 | Waters, Agilent | 不同品牌使用相同零件号 |
| 186009298 | 2 | Waters, Thermo Fisher | 不同品牌使用相同零件号 |
| ... | ... | ... | ... |

**结论**: 
- **productId是绝对唯一的**（因为包含品牌前缀）
- **partNumber在同一品牌内唯一，但可能跨品牌重复**
- **冲突判断应基于productId（品牌+零件号）**

---

## 第二部分：冲突场景分析

### 2.1 可能的冲突场景

当新爬取的数据导入时，可能出现以下场景：

#### 场景1：完全新产品（无冲突）

**情况**: 新产品的productId在数据库中不存在

**示例**:
- 新产品：`AGIL-820750-999`（Agilent新型号）
- 数据库中没有这个productId

**处理策略**: **直接插入**

---

#### 场景2：产品已存在（冲突）

**情况**: 新产品的productId在数据库中已存在

**示例**:
- 新产品：`AGIL-820750-902`
- 数据库中已有：`AGIL-820750-902`

**可能原因**:
1. 官网更新了产品信息（名称、规格、描述等）
2. 之前的数据不完整，新数据更完整
3. 之前的数据有错误，新数据更准确

**处理策略**: **更新现有产品**（详见下文）

---

#### 场景3：零件号相同但品牌不同（非冲突）

**情况**: 新产品的partNumber与现有产品相同，但brand不同

**示例**:
- 新产品：`AGIL-186000273`（Agilent）
- 数据库中已有：`WATS-186000273`（Waters）

**处理策略**: **视为不同产品，直接插入**（因为productId不同）

---

### 2.2 数据来源优先级

当新旧数据冲突时，需要确定哪个数据源更可靠：

| 数据源 | 可靠性 | 完整性 | 准确性 | 优先级 |
|--------|--------|--------|--------|--------|
| **新爬取数据**（官网） | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | **高** |
| **现有数据**（CSV导入） | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | 低 |

**结论**: **新爬取数据优先** - 因为直接来自官网，更准确、更新

---

## 第三部分：数据更新策略

### 3.1 核心策略：智能合并

**策略名称**: **智能合并（Smart Merge）**

**核心原则**:
1. **基于productId判断冲突**（品牌+零件号）
2. **新数据优先更新**（覆盖旧数据）
3. **保留关联关系**（分类、询价记录等）
4. **不删除旧产品**（除非明确要求）

---

### 3.2 详细更新规则

#### 规则1：新产品（productId不存在）

**操作**: **INSERT**（插入新产品）

**SQL逻辑**:
```sql
INSERT INTO products (productId, partNumber, brand, name, ...)
VALUES ('AGIL-820750-999', '820750-999', 'Agilent', 'New Product', ...);
```

**影响**: 
- 产品总数 +1
- 无任何冲突

---

#### 规则2：产品已存在（productId存在）

**操作**: **UPDATE**（更新现有产品）

**更新字段**:
- ✅ 更新：`name`, `productType`, `description`, `specifications`
- ✅ 更新：所有规格字段（`particleSize`, `poreSize`, `columnLength`等）
- ✅ 更新：`imageUrl`, `catalogUrl`, `applications`
- ❌ 不更新：`id`（主键）
- ❌ 不更新：`productId`, `partNumber`, `brand`, `prefix`（标识字段）
- ❌ 不更新：`createdAt`（创建时间）
- ✅ 更新：`updatedAt`（更新时间）

**SQL逻辑**:
```sql
INSERT INTO products (productId, partNumber, brand, name, ...)
VALUES ('AGIL-820750-902', '820750-902', 'Agilent', 'Updated Name', ...)
ON DUPLICATE KEY UPDATE
  name = VALUES(name),
  productType = VALUES(productType),
  description = VALUES(description),
  ...
  updatedAt = NOW();
```

**影响**:
- 产品总数不变
- 产品信息更新为最新
- **关联关系保留**（分类、询价记录等通过`id`关联，不受影响）

---

#### 规则3：零件号相同但品牌不同

**操作**: **INSERT**（视为不同产品）

**示例**:
- 新产品：`AGIL-186000273`
- 现有产品：`WATS-186000273`
- 结果：两个产品共存

**SQL逻辑**:
```sql
INSERT INTO products (productId, partNumber, brand, name, ...)
VALUES ('AGIL-186000273', '186000273', 'Agilent', 'Product Name', ...);
-- 不会与 WATS-186000273 冲突，因为productId不同
```

**影响**:
- 产品总数 +1
- 两个品牌的同零件号产品共存

---

### 3.3 数据清理策略

#### 问题：是否需要删除旧产品？

**答案**: **通常不需要**

**原因**:
1. **关联关系**: 旧产品可能已被加入询价单、购物车
2. **历史记录**: 删除会导致历史数据丢失
3. **数据完整性**: 删除可能破坏外键约束

**推荐做法**: **标记而非删除**

---

#### 标记策略：使用status字段

**现有status值**:
- `new` - 新产品
- `active` - 活跃产品
- `discontinued` - 已停产

**建议新增status值**:
- `replaced` - 已被新数据替换（但保留记录）

**实施方案**:

1. **导入新数据时**:
   - 如果productId已存在 → UPDATE现有产品
   - 不创建新记录，不标记为replaced

2. **如果需要清理旧数据**（可选）:
   - 识别"长期未更新"的产品（如6个月未更新）
   - 标记为`discontinued`
   - 在前端隐藏，但保留数据库记录

---

## 第四部分：实施方案

### 4.1 导入脚本逻辑

**现有脚本**: `import-crawler-data.mjs`

**当前逻辑**: 已实现智能合并（ON DUPLICATE KEY UPDATE）

**验证**:
```javascript
await db.insert(products).values(product).onDuplicateKeyUpdate({
  set: {
    name: product.name,
    productType: product.productType,
    // ... 其他字段
    updatedAt: new Date(),
  },
});
```

✅ **脚本已正确实现智能合并策略**

---

### 4.2 导入流程

**步骤1**: 接收爬虫任务返回的CSV文件

**步骤2**: 运行导入脚本
```bash
node import-crawler-data.mjs ./agilent_products_test_20250103.csv
```

**步骤3**: 脚本自动处理
- 验证数据格式
- 识别新产品 vs 已存在产品
- 新产品 → INSERT
- 已存在产品 → UPDATE
- 生成导入报告

**步骤4**: 审查导入报告
- 查看新增产品数量
- 查看更新产品数量
- 查看失败产品（如果有）

**步骤5**: 验证网站展示
- 检查产品详情页
- 确认数据更新正确

---

### 4.3 数据清理（可选）

**如果需要清理旧数据**，可以运行以下SQL：

```sql
-- 标记6个月未更新的产品为discontinued
UPDATE products
SET status = 'discontinued'
WHERE updatedAt < DATE_SUB(NOW(), INTERVAL 6 MONTH)
  AND status = 'new';
```

**注意**: 
- 不建议删除产品
- 仅标记为discontinued
- 前端可以过滤掉discontinued产品

---

## 第五部分：常见问题解答

### Q1: 新数据导入后，产品总数会增加吗？

**A**: 取决于情况

- **场景1**: 如果新数据全是新产品（productId不存在）→ 产品总数增加
- **场景2**: 如果新数据全是已存在产品（productId存在）→ 产品总数不变，仅更新
- **场景3**: 如果新数据混合（部分新，部分已存在）→ 产品总数增加部分新产品的数量

**示例**:
- 现有产品：2,623个
- 新爬取：100个产品
  - 其中50个是新产品（productId不存在）
  - 其中50个是已存在产品（productId存在）
- 导入后：2,623 + 50 = **2,673个产品**

---

### Q2: 旧产品信息会丢失吗？

**A**: 不会丢失，但会被更新

- **产品ID不变**（id, productId, partNumber, brand）
- **关联关系不变**（分类、询价记录等）
- **产品信息更新**（name, description, specifications等）
- **创建时间不变**（createdAt）
- **更新时间更新**（updatedAt）

**如果需要保留历史版本**:
- 可以在导入前备份数据库
- 或者实现产品版本历史功能（未来扩展）

---

### Q3: 如果新数据有错误怎么办？

**A**: 可以回滚

**方法1**: 从数据库备份恢复
```bash
# 导入前备份
mysqldump -u user -p database > backup_20250103.sql

# 如果需要回滚
mysql -u user -p database < backup_20250103.sql
```

**方法2**: 使用导入报告手动修正
- 查看导入报告中的失败产品
- 手动修正错误数据
- 重新导入

---

### Q4: 如何处理品牌不同但零件号相同的产品？

**A**: 视为不同产品

- **productId不同** → 不会冲突
- **两个产品共存** → 都保留在数据库中
- **前端展示** → 分别显示在各自品牌下

**示例**:
- `WATS-186000273` - Waters品牌
- `AGIL-186000273` - Agilent品牌
- 两者共存，互不影响

---

### Q5: 需要删除旧产品吗？

**A**: **通常不需要**

**原因**:
1. 旧产品可能已被加入询价单
2. 删除会破坏数据完整性
3. 更新策略已经覆盖了旧数据

**如果确实需要清理**:
- 使用`status`字段标记为`discontinued`
- 前端过滤掉discontinued产品
- 保留数据库记录

---

## 第六部分：推荐操作流程

### 小规模测试阶段（当前）

**步骤1**: 等待爬虫任务返回Agilent的50-100个产品

**步骤2**: 运行导入脚本
```bash
node import-crawler-data.mjs ./agilent_products_test_20250103.csv
```

**步骤3**: 审查导入报告
- 新增产品数量
- 更新产品数量
- 失败产品（如果有）

**步骤4**: 验证网站
- 检查Agilent产品列表
- 查看产品详情页
- 确认数据更新正确

**步骤5**: 决策
- 如果成功 → 进入全面爬取阶段
- 如果失败 → 分析问题，调整策略

---

### 全面爬取阶段（未来）

**步骤1**: 爬虫任务爬取11个品牌的所有产品

**步骤2**: 分批导入（推荐）
```bash
# 按品牌分批导入
node import-crawler-data.mjs ./agilent_products_full.csv
node import-crawler-data.mjs ./waters_products_full.csv
node import-crawler-data.mjs ./thermo_products_full.csv
...
```

**步骤3**: 审查每批导入报告

**步骤4**: 全面验证网站

**步骤5**: 数据清理（可选）
- 标记长期未更新的产品为discontinued

---

## 第七部分：风险和应对

### 风险1：数据覆盖错误

**风险**: 新数据有错误，覆盖了正确的旧数据

**应对**:
- ✅ 导入前备份数据库
- ✅ 审查导入报告
- ✅ 随机抽查更新的产品
- ✅ 如果发现错误，从备份恢复

---

### 风险2：关联关系丢失

**风险**: 更新产品后，分类或询价记录丢失

**应对**:
- ✅ 使用ON DUPLICATE KEY UPDATE（不改变id）
- ✅ 关联关系通过id维护，不受影响
- ✅ 导入后验证关联关系

---

### 风险3：性能问题

**风险**: 大量数据导入导致数据库性能下降

**应对**:
- ✅ 分批导入（每批500-1000个产品）
- ✅ 在低峰时段导入
- ✅ 监控数据库性能

---

## 总结

### 核心策略

**智能合并（Smart Merge）**:
1. 基于productId判断冲突
2. 新数据优先更新
3. 保留关联关系
4. 不删除旧产品

### 关键优势

✅ **数据完整性**: 不破坏现有关联关系  
✅ **数据准确性**: 新数据优先，确保最新信息  
✅ **灵活性**: 支持新产品和更新产品  
✅ **可追溯性**: 保留updatedAt时间戳  
✅ **安全性**: 可备份和回滚  

### 下一步行动

1. **等待爬虫任务返回CSV文件**
2. **运行导入脚本**
3. **审查导入报告**
4. **验证网站展示**
5. **根据结果决定下一步**

---

**文档完成。如有任何问题，请随时咨询。**
